# week12

主观题参考答案在 [ANSWERS.md](ANSWERS.md) 中，函数题及编程题参考答案为同目录下的 `.cpp` 文件。

<!-- TOC -->

- [函数题](#函数题)
  - [字符统计](#字符统计)
- [编程题](#编程题)
  - [哈希函数1](#哈希函数1)
  - [哈希函数2](#哈希函数2)
  - [电话聊天狂人](#电话聊天狂人)
  - [词频统计](#词频统计)
- [主观题](#主观题)
  - [Problem 1](#problem-1)
  - [Problem 2](#problem-2)

<!-- /TOC -->

## 函数题

### 字符统计
输入一个字符串，统计改字符串中出现的字符及其次数。要求用一个二叉排序树保存处理结果。输出时字符从小到大有序。
本题目要求完成函数 `InsertBiTree` 和 `InOrderTraverse`

函数接口定义:
```c++
Status InsertBiTree(BiTree &T,char ch);
Status InOrderTraverse(BiTree T);
// 其中 T 和 ch 都是用户传入的参数。 T是一棵二叉排序树；ch 是一个字符。
// 函数InsertBiTree的功能是查找树 T中是否存有字符ch，有就个数加一，没有则新插入一个值为ch的结点。
// 函数InOrderTraverse完成对二叉树T的中序遍历，输出统计结果。
```

裁判测试程序样例:
```c++
#include <stdio.h>
#include <stdlib.h>

#define OK (1)
#define ERROR (-1)
typedef int Status;
typedef struct ch
{ char zifu;  //字符
  int count;   //个数
}TElemType;

//- - - - -二叉树的二叉链表存储表示- - - - -
typedef  struct  BiTNode
{  TElemType     data;              //需要定义 TElemType, 为char类型
   struct BiTNode  *lchild, *rchild;   //左右孩子指针
} BiTNode, *BiTree;

/* 请在这里填写答案 */

int main( )
{ BiTree tree=NULL;
  int i;
  char s[100];
  scanf("%s",s);
  for(i=0; s[i]; i++)
     InsertBiTree(tree,s[i]);
  InOrderTraverse(tree);
  return 0;
}
```
输入样例:
```
bacadab
```
输出样例:
```
a:3
b:2
c:1
d:1
```

## 编程题

### 哈希函数1
设哈希表长为 `18` ,哈希函数为: `H(k)=k MOD 17` 建立对应的哈希表。采用开放地址法中的二次探测再散列解决冲突，完成以下工作:  
(1) 查找值为 `x` 的元素地址(位置)。找不到则输出 `-1` 。  
(2) 删除关键字为 `t1, t2` 的元素，再添加关键字为 `y` 的元素  
(3) 输出整个哈希表(用 `%4d` 格式，没有数据则输出4个 `*` )

输入格式:  
输入分2部分:  
第一部分是初始元素个数和序列，第二部分是 `x, t1, t2, y` 的值，分3行输入。

输出格式:  
输出数据共2行:  
第一行是 `x` 的地址，第二行是最后的哈希表

输入样例:
```
12
16 74 60 43 54 90 46 31 29 88 77 26
77
77 90
98
```
输出样例:
```
8
  26********  54  88****  74********  60  43****  46  29  31****  16  98
```

### 哈希函数2
设哈希表长为 `10` ，哈希函数为: `H(k)=k MOD 10` 建立对应的哈希表。采用链地址法解决冲突。先建立哈希表，再删除 `x` ，插入 `y` 后，输出哈希表。

输入格式:  
输入数据为初始元素个数和序列，以及 `x, y` 的值

输出格式:  
输出数据为最后的哈希表

输入样例:
```
12
16 74 60 43 54 90 46 31 29 88 77 26
77 38
```
输出样例:
```
0->90->60^
1->31^
2^
3->43^
4->54->74^
5^
6->26->46->16^
7^
8->38->88^
9->29^
```

### 电话聊天狂人
给定大量手机用户通话记录，找出其中通话次数最多的聊天狂人。

输入格式:  
输入首先给出正整数 `N` (≤10<sup>5</sup>)，为通话记录条数。随后N行，每行给出一条通话记录。简单起见，这里只列出拨出方和接收方的11位数字构成的手机号码，其中以空格分隔。

输出格式:  
在一行中给出聊天狂人的手机号码及其通话次数，其间以空格分隔。如果这样的人不唯一，则输出狂人中最小的号码及其通话次数，并且附加给出并列狂人的人数。

输入样例:
```
4
13005711862 13588625832
13505711862 13088625832
13588625832 18087925832
15005713862 13588625832
```
输出样例:
```
13588625832 3
```

### 词频统计
请编写程序，对一段英文文本，统计其中所有不同单词的个数，以及词频最大的前 `10%` 的单词。

所谓“单词”，是指由不超过 `80` 个单词字符组成的连续字符串，但长度超过 `15` 的单词将只截取保留前 `15` 个单词字符。而合法的“单词字符”为大小写字母、数字和下划线，其它字符均认为是单词分隔符。

输入格式:  
输入给出一段非空文本，最后以符号 `#` 结尾。输入保证存在至少 `10` 个不同的单词。

输出格式:  
在第一行中输出文本中所有不同单词的个数。注意“单词”不区分英文大小写，例如 `PAT` 和 `pat` 被认为是同一个单词。

随后按照词频递减的顺序，按照词频:单词的格式输出词频最大的前 `10%` 的单词。若有并列，则按递增字典序输出。

输入样例:
```
This is a test.

The word "this" is the word with the highest frequency.

Longlonglonglongword should be cut off, so is considered as the same as longlonglonglonee.  But this_8 is different than this, and this, and this...#
this line should be ignored.
```
输出样例:(注意：虽然单词 `the` 也出现了 `4` 次，但因为我们只要输出前 `10%` (即 `23` 个单词中的前 `2` 个)单词，而按照字母序， `the` 排第 `3` 位，所以不输出。)
```
23
5:this
4:is
```

## 主观题

### Problem 1
选取哈希函数 `H(k)=(3k) MOD 11` ，用开放定址法处理冲突， d<sub>i</sub>=i((7k) MOD 10 + 1)(i=1, 2, 3, ...)。试在0-10的散列地址空间中对关键字序列 `(22, 41, 53, 46, 30, 13, 01)` 造哈希表，并求等概率情况下查找成功时的平均查找长度。

### Problem 2
对关键字序列 `(503, 087, 512, 061, 908, 170, 897, 275, 653, 426)` 写出每一趟排序结束时的排序结果。  
(1) 直接插入排序；  
(2) 希尔排序(增量序列为 `5, 3, 1` )；  
(3) 快速排序。
